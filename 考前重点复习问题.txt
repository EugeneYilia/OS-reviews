1.进程与线程的区别
  进程是资源分配的最小单位，线程是程序执行的最小单位
  进程有自己的独立地址空间，每启动一个进程，启动就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作
  非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个
  线程的开销远比进程要小很多
  线程之间通信很方便，统一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式(IPC)进行，不过
  如何处理好同步与互斥是编写多线程程序的难点
  多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也就死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为
  进程有自己独立的地址空间
  
  进程与程序的区别 
  进程和程序的组成是不同的。进程是动态的，程序是静态的，程序是有序代码的集合，进程是程序的执行
  进程是暂时的，是程序在数据集上的依次执行;程序是永久的
  进程具有并发行，而程序没有
  进程是竞争计算机资源的基本单位而程序不是
  一个程序可以对应多个进程，而一个进程只能对应一个程序
2.系统调用由操作系统实现提供的所有系统调用所构成的集合即程序接口或应用编程接口，是应用程序同系统之间的接口
  是运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。
  系统调用的就是内核提供的、功能十分强大的一系列的函数，这些系统调用是在内核中实现的，再通过一定的方式把系统调用
  给用户
  系统调用的本质;为内核函数提供外部接口，进入内核后，不同的系统调用会找到各自对应的内核函数，这些内核函数被称为
  系统调用的服务例程
3.文件:用于存储相关数据
  目录:用于组织系统内的文件并提供有关文件的信息
       记录卷上所有文件的信息如名称、位置、大小和类型等
4.中断:中断是指在计算机执行期间，系统内发生任何非寻常或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去
       执行相应的事件处理程序，待处理完毕又返回原来被中断处继续执行或调度新的进程执行的过程
5.异常:异常也称内中断、例外或陷入(trap),指源自CPU执行指令内部的事件的发生，如程序的非法操作码、地址越界、算术溢出、
       虚拟内存系统的缺页以及专门的陷入指令等引起的事件
       对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现应立即处理
6.护航效应(Convoy effect):很多小进程在等待一个大进程释放CPU
7.进程控制块:所包含的内容
  1.进程状态
  2.程序计数器
  3.CPU寄存器
  4.CPU调度信息
  5.内存管理信息
  6.记账信息
  7.I/O状态信息
8.SPOOLing
  利用高速的共享设备，将独享设备变成逻辑上可共享的虚拟设备的技术，以提高设备利用率
9.Overlays
  为了能让进程比他所分配到的内存空间大，只在内存中保存所需的指令和数据，当需要其他指令时，
  他们会装入到刚刚不再需要的指令的内存空间
10.#系统调用的种类和类别
   #通常在操作系统内核设置有一组用于实现各种系统功能的子程序(过程)并将它们提供给用户程序调用。每当用户在程序中需要
   #操作系统提供某种服务时，便可利用一条条系统调用命令去调用所需的系统过程。
   #1).进程控制类
   #2).文件操作类
   #3).进程通信类
   #4).信息维护类

   系统调用就是进程与操作系统之间的接口
   系统调用提供了进程与操作系统之间的接口，在最底层，系统调用允许运行程序直接向操作系统发出请求，系统调用允许用户组进程向
   操作系统请求服务
   系统调用分五类：进程控制，文件管理，设备管理，信息维护，通信
   进程控制:创建进程、终止进程、取得进程属性等
   文件管理:创建删除文件，对文件打开关闭，读写以及重定位，取得文件属性等。
   设备管理:请求释放设备，对设备读写已经重定位，取得设备信息等
   信息维护:用户程序与操作系统之间的信息传递，可以访问操作系统的进程信息
   通信:创建删除通信连接、发送接收信息、连接中断远程设备等
11.三种硬盘空间的分配方式
   1).连续分配:要求每个文件在磁盘上占有一组连续的块
   2).链接分配:每个文件是磁盘块的链表，只需开始块的地址即可
   3).索引分配:把指向文件的所有指针单独存到了索引块中，目录条目中包含了索引块的地址
   
   FAT:链接分配
   Unix File System:索引分配
12.外部碎片:随着进程装入和移出内存，自由空间被分成小片段，当所有总的内存之和满足请求但不连续时，就会出现外部碎片的现象
   内部碎片:将内存以固定大小的单元分配，进程所分配的可能比所需要的大，这两个数字之差成为内部碎片，这部分内存在分区内而
            又不能用
13.CPU调度准则
   周转时间:从进程提交到进程完成的时间段称为周转时间
   等待时间:在就绪队列中等待所花费时间之和
14.P，V操作
   就是对信号量的两个标准原子操作wait()和signal()
   P是减少wait，V是释放signal
15.用户线程与内核线程的区别
   用户线程：可以运行在内核态(执行系统调用时)，也可以运行在用户态，利用线程库进行创建、同步、调度和管理
   内核线程：只工作在内核态，由操作系统内核创建和撤销
16.临界区
   有多个进程，每个进程有一个代码段可能改变共同变量、更新一个表、写一个文件等，这种代码段称之为临界区
17.层次页表  将之前页表中页码的部分再进行分页，构成外页表和内页表
   反向页表  系统中只有一个页表，其中的每一项由进程号、页号和偏移量构成
   哈希页表  以虚拟页码作为哈希值，每一条目都包含一个链表的元素，每个元素包括虚拟页码，所映射的帧好，指向下一个元素的指针
18.分页  逻辑上连续、物理上离散
         分页分得过大的话，内部碎片过大，会浪费内存
         分页分得过小的话，需要的页表会变大，页表会占用内存，并且查找页的过程会变慢
19.TLB   转换表缓冲区，采用小但专用且快速的硬件缓冲，这种缓冲成为转换表缓冲区
         缓冲一些页号与帧号的对应关系
         作为一种寄存器，不在cache中也不在主存中
20.OPT(optimal page-replacement)   最优页置换算法，向将来看，最远使用的元素将被替换
   LRU(least-recently-used)   最近最少使用替换算法，向过去看，最久未使用的元素将被替换
   近似LRU页置换  二次机会页置换算法，弥补一些FIFO页置换的缺陷
   LFU(least frequently used page-replacement)使用次数最少的页将被进行替换
   MFU(most frequently used page-replacement)使用次数最多的页将被进行替换
21.monitor管城:资源管理程序，将资源和对资源的操作封装起来，资源使用者通过接口操作资源，不用去考虑进程同步的问题
22.进程间通信的方式
   共享内存系统
   消息传递系统
   1).直接通信  通过原语send,receive进行通信
   2).间接通信  通过邮箱进行通信
                通过消息队列进行通信
23.primitive原语
   有若干条指令组成的，用于完成一定功能的一个过程。是由若干个机器指令构成的完成某种特定功能的一段程序，具有不可分割性，
   原语的执行必须是连续的，在执行过程中不允许被中断。
24.swapping
   进程需要在内存中以便执行，不过进程可以暂时从内存中交换出来到备份存储上，当需要执行时再调回到内存中
25.只要保证任意时刻至少有一个进程拥有两个资源，那么系统就不会死锁，所以0<N<6就不会产生死锁
26.critical section
   进程中关于临界资源的代码段
27.Directory
   对文件实施有效管理，将他们妥善的管理起来
28.程序是完成所需要的功能时，所应采取的顺序步骤，是执行指令的有序集合
   进程是执行中的程序。包括程序计数器，进程堆栈段，数据段。
29.thrashing 系统颠簸
   频繁的页调度行为称为颠簸
   内存中的帧不够用，换出的页又被需要又需要被换入，进程就主要忙于调页，系统不能完成一件工作。
   给进程提供足够多的帧，比如选择一个进程进行挂起，将其帧分配给其他进程来终止系统颠簸。
30.页和帧都是从零开始计数的
31.操作系统的主要活动
   A.User management  B.Main memory management
   C.I/O system management D.File management
   BCD
32.blocked
   进程正在等待某一个事件且在二级存储器中
33.overlay
   一个作业的若干程序段或几个作业的某些部分共享某一个存储空间
   在多道程序环境下扩充内存的方法，用以解决在较小的存储空间中运行较大程序时遇到的问题
   把程序划分为若干个功能上相互独立的程序段，按照其自身的逻辑结构将那些不会同时执行的程序段共享同一块内存区域
   程序段现保存在磁盘上，当有关程序短段的一部分执行结束后，把后续程序段调入内存，覆盖前面的程序段



















